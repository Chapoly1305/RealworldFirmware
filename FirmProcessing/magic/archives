# MicroChip PIC24/33 Image Hex file
# PIC24/33 use Flash-Based Configuration Register
0    string    :020000040000fa\r\n:020000040002f8\r\n:04aff000 _Microchip,PIC24/33,firmware for 256K flash,

# PIC18 use 300000h-300008h to manage the memory configuration
0    regex     (?i):020000040030CA\r?\n:0E000000 _Microchip,PIC18,Firmwares Memory Configuration bits

# ----------------------------Archive Formats--------------------------------------

# POSIX tar archives
257     string      ustar\00000   POSIX tar archive
>8      byte        !0
>>8     string      x           \b, owner user name: "%.32s"
>40     byte        !0
>>40    string      x           \b, owner group name: "%.32s"

257     string      ustar\040\040\000    POSIX tar archive (GNU)
>8      byte        !0
>>8     string      x                    \b, owner user name: "%.32s"
>40     byte        !0
>>40    string      x                    \b, owner group name: "%.32s"

# Incremental snapshot gnu-tar format from:
# http://www.gnu.org/software/tar/manual/html_node/Snapshot-Files.html
0       string      GNU\x20tar-     GNU tar incremental snapshot data,
>0      string      x               version: "%s"

# JAR archiver (.j), this is the successor to ARJ, not Java's JAR (which is essentially ZIP)
14      string  \x1aJar\x1b     JAR (ARJ Software, Inc.) archive data
0       string  JARCS           JAR (ARJ Software, Inc.) archive data

# PKZIP multi-volume archive
0       string          PK\x07\x08PK\x03\x04    Zip multi-volume archive data, at least PKZIP v2.50 to extract

# ZIP compression (Greg Roelofs, c/o zip-bugs@wkuvx1.wku.edu)
0       string      PK\003\004      {location:0}Zip archive data,
>6      leshort     &0x01           encrypted
>4      byte        0x00            v0.0
>4      byte        0x09            at least v0.9 to extract,
>4      byte        0x0a            at least v1.0 to extract,
>4      byte        0x0b            at least v1.1 to extract,
>0x161  string      WINZIP          WinZIP self-extracting,
>4      byte        0x14
>>30    ubelong     !0x6d696d65     at least v2.0 to extract,
>4      byte        0x2d
>>30    ubelong     !0x6d696d65     at least v3.0 to extract,

# From: https://github.com/threatstack/libmagic/blob/master/magic/Magdir/archive
# Specialised zip formats which start with a member named 'mimetype'
# (stored uncompressed, with no 'extra field') containing the file's MIME type.
# Check for have 8-byte name, 0-byte extra field, name "mimetype", and
# contents starting with "application/". These aren't normal ZIP files and they
# don't extract properly; mark them as invalid.
>26	string	    \x08\x00\x00\x00mimetypeapplication/    OpenDocument Text,{invalid}

>18     lelong      !0
>>18    lelong      x              compressed size: %d,
>>18    ulelong	    !0xFFFFFFFF
>>>18   ulelong     x              {jump:%d}
>22     lelong      !0
>>22    lelong     x               uncompressed size: %d,
>30     byte        <0x2D           {invalid}
>30     byte        >0x7A           {invalid}
>26     leshort     x               {strlen:%d}
>30     string      x               name: {string}%s


# ZIP footer
0       string      PK\x05\x06      End of Zip archive,
>20	leshort+22  <1		    invalid{invalid}
>20     leshort+22  x               footer length: %d
>20     leshort     >0
>>20    leshort     x               \b, comment:
>>20    leshort     x               {strlen:%d}
>>22    string      x               {string}"%s"

# ARJ archiver (jason@jarthur.Claremont.EDU)
0       uleshort    0xea60      ARJ archive data,
>2      leshort     x           header size: %d,
>5      byte        <1          {invalid}
>5      byte        >16         {invalid}
>5      byte        x           version %d,
>6      byte        <1          {invalid}
>6      byte        >16         {invalid}
>6      byte        x           minimum version to extract: %d,
>8      byte        <0          {invalid} flags,
>8      byte        &0x04       multi-volume,
>8      byte        &0x10       slash-switched,
>8      byte        &0x20       backup,
>9      byte        <0          {invalid},
>9      byte        >4          {invalid},
>9      byte        0           compression method: stored,
>9      byte        1           compression method: compressed most,
>9      byte        2           compression method: compressed,
>9      byte        3           compression method: compressed faster,
>9      byte        4           compression method: compressed fastest,
>10     byte        <0          {invalid}
>10     byte        >4          {invalid}
>10     byte        0           file type: binary,
>10     byte        1           file type: 7-bit text,
>10     byte        2           file type: comment header,
>10     byte        3           file type: directory,
>10     byte        4           file type: volume label,
>34     byte        !0
>>34    string      x           {name:%s}
>>34    string      x           original name: "%s",
>0xC    uledate      x           original file date: %s,
>0x10   lelong      <0          {invalid}
>0x10   lelong      x           compressed file size: %d,
>0x14   lelong      <0          {invalid}
>0x14   lelong      x           uncompressed file size: %d,
>7      byte        0           os: MS-DOS
>7      byte        1           os: PRIMOS
>7      byte        2           os: Unix
>7      byte        3           os: Amiga
>7      byte        4           os: Macintosh
>7      byte        5           os: OS/2
>7      byte        6           os: Apple ][ GS
>7      byte        7           os: Atari ST
>7      byte        8           os: NeXT
>7      byte        9           os: VAX/VMS
>7      byte        >9          {invalid}
>7      byte        <0          {invalid}

# RAR archiver (http://archive.today/2014.05.14-050637/http://kthoom.googlecode.com/hg/docs/unrar.html, https://www.rarlab.com/technote.htm#rarsign)
0   string      \x52\x61\x72\x21\x1A\x07            RAR archive data,
>6  ubyte       >1                                  unknown version{invalid}
>6  ubyte       1                                   version 5.x
>6  ubyte       0                                   version 4.x, first volume type:
>>9  ubyte       <0x72                               {invalid}
>>9  ubyte       >0x7B                               {invalid}
>>9  ubyte       0x72                                MARK_HEAD
>>9  ubyte       0x73                                MAIN_HEAD
>>9  ubyte       0x74                                FILE_HEAD
>>9  ubyte       0x75                                COMM_HEAD
>>9  ubyte       0x76                                AV_HEAD
>>9  ubyte       0x77                                SUB_HEAD
>>9  ubyte       0x78                                PROTECT_HEAD
>>9  ubyte       0x79                                SIGN_HEAD
>>9  ubyte       0x7A                                NEWSUB_HEAD
>>9  ubyte       0x7B                                ENDARC_HEAD

# HPACK archiver (Peter Gutmann, pgut1@cs.aukuni.ac.nz)
0    string        HPAK        HPACK archive data

# JAM Archive volume format, by Dmitry.Kohmanyuk@UA.net
0    string        \351,\001JAM    JAM archive

# LHARC/LHA archiver (Greg Roelofs, newt@uchicago.edu)
2    string        -lzs         LHa 2.x? archive data [lzs] [NSRL|LHA2]
>6   string        !-           {invalid}
2    string        -lh\40       LHa 2.x? archive data [lh ] [NSRL|LHA2]
>6   string        !-           {invalid}
2    string        -lhd         LHa 2.x? archive data [lhd] [NSRL|LHA2]
>6   string        !-           {invalid}
2    string        -lh2         LHa 2.x? archive data [lh2] [NSRL|LHA2]
>6   string        !-           {invalid}
2    string        -lh3         LHa 2.x? archive data [lh3] [NSRL|LHA2]
>6   string        !-           {invalid}
2    string        -lh4         LHa (2.x) archive data [lh4] [NSRL|LHA2]
>6   string        !-           {invalid}
2    string        -lh5         LHa (2.x) archive data [lh5] [NSRL|LHA2]
>6   string        !-           {invalid}
2    string        -lh6         LHa (2.x) archive data [lh6] [NSRL|LHA2]
>6   string        !-           {invalid}
2    string        -lh7         LHa (2.x) archive data [lh7] [NSRL|LHA2]
>6   string        !-           {invalid}


# cpio archives
#
# The SVR4 "cpio(4)" hints that there are additional formats, but they
# are defined as "short"s; I think all the new formats are
# character-header formats and thus are strings, not numbers.
#0       string          070707          ASCII cpio archive (pre-SVR4 or odc)

0       string      070701  {location:0}ASCII cpio archive (SVR4 with no CRC),
>110    byte        0       {invalid}
>94     byte        <0x30   {invalid}
>94     byte        >0x66   {invalid}
>54     byte        <0x30   {invalid}
>54     byte        >0x66   {invalid}
>110    string      x       file name: "%s",
>94     string      x       file name length: "0x%.8s",
>54     string      x       file size: "0x%.8s"

0       string      070702  {location:0}ASCII cpio archive (SVR4 with CRC)
>110    byte        0       {invalid}
>94     byte        <0x30   {invalid}
>94     byte        >0x66   {invalid}
>54     byte        <0x30   {invalid}
>54     byte        >0x66   {invalid}
>110    string      x       file name: "%s",
>94     string      x       file name length: "0x%.8s",
>54     string      x       file size: "0x%.8s"

# HP Printer Job Language
# The header found on Win95 HP plot files is the "Silliest Thing possible"
# (TM)
# Every driver puts the language at some random position, with random case
# (LANGUAGE and Language)
# For example the LaserJet 5L driver puts the "PJL ENTER LANGUAGE" in line 10
# From: Uwe Bonnes <bon@elektron.ikp.physik.th-darmstadt.de>
#
0       string          \033%-12345X@PJL    HP Printer Job Language data,
>0      string          x                   "%s"

#------------------------------------------------------------------------------
#
# RPM: file(1) magic for Red Hat Packages   Erik Troan (ewt@redhat.com)
#
0     ubelong       0xedabeedb   RPM
>4    byte          <1           {invalid}
>4    byte          >99          {invalid}
>4    byte          x            v%d
>6    beshort       0            bin
>6    beshort       1            src
>8    beshort       1            i386
>8    beshort       2            Alpha
>8    beshort       3            Sparc
>8    beshort       4            MIPS
>8    beshort       5            PowerPC
>8    beshort       6            68000
>8    beshort       7            SGI
>8    beshort       8            RS6000
>8    beshort       9            IA64
>8    beshort       10           Sparc64
>8    beshort       11           MIPSel
>8    beshort       12           ARM
>10   string        x            "%s"

# IBM AIX Backup File Format header and entry signatures
0     ulelong    0xea6b0009   BFF volume header,
>4    uleshort   x            checksum: 0x%.4X,
>6    leshort    <0           {invalid}
>6    leshort    0            {invalid}
>6    leshort    x            volume number: %d,
>8    uledate     x            current date: %s,
>12   uledate     x            starting date: %s,
>20   string     x            disk name: "%s",
>36   string     x            file system name: "%s",
>52   string     x            user name: "%s"

2     uleshort  0xea6b      BFF volume entry,
>22   lelong    <0          {invalid}
>22   lelong    0           directory,
>22   lelong    >0
>>22  lelong    x           file size: %d,
>>54  lelong    <0          {invalid}
>>54  lelong    0           {invalid}
>>54  lelong    x           compressed size: %d,
>58   lelong    !0          {invalid}
>62   byte      0           {invalid}
>62   byte      !0x2e
>>62  byte      !0x2f       {invalid}
>62   string    x           file name: "%s"

2       uleshort    0xea6c  BFF volume entry, compressed,
>22     lelong      <0      {invalid}
>22     lelong      0       directory,
>22     lelong      >0
>>22    lelong      x       file size: %d,
>>54    lelong      <0      {invalid}
>>54    lelong      0       {invalid}
>>54    lelong      x       compressed size: %d,
>58     lelong      !0      {invalid}
>62     byte        0       {invalid}
>62     byte        !0x2e
>>62    byte        !0x2f   {invalid}
>62     string      x       file name: "%s"

0       uleshort    0xea6d  BFF volume entry, AIXv3,
>22     lelong      <0      {invalid}
>22     lelong      0       directory,
>22     lelong      >0
>>22    lelong      x       file size: %d,
>>54    lelong      <0      {invalid}
>>54    lelong      0       {invalid}
>>54    lelong      x       compressed size: %d,
>58     lelong      !0      {invalid}
>62     byte        0       {invalid}
>62     byte        !0x2e
>>62    byte        !0x2f   {invalid}
>62     string      x       file name: "%s"

#------------------------------------------------------------------------------
# From Stuart Caie <kyzer@4u.net> (developer of cabextract)
# Microsoft Cabinet files
0       string      MSCF\0\0\0\0    Microsoft Cabinet archive data
# According to libmagic comments, CAB version number is always 1.3
>25     byte        !1              {invalid}
>24     byte        !3              {invalid}
>8      lelong      x               \b, %u bytes
>28     leshort     0               {invalid}
>28     leshort     1               \b, 1 file
>28     leshort     >1              \b, %u files

# InstallShield Cabinet files
0               string          ISc(            InstallShield Cabinet archive data
# TODO: Version number checks should be made more specific for false positive filtering
>5              byte&0xf0       =0x60           version 6,
>5              byte&0xf0       <0x60           version 4/5,
>5              byte&0xf0       >0x60           {invalid} version,
>12             lelong          <0              {invalid} offset,
>12             lelong          >100000         {invalid} offset,
>(12.l+40)      lelong          x               %u files

# Windows CE package files
0       string          MSCE\0\0\0\0    Microsoft WinCE install header
>20     lelong          0               \b, architecture-independent
>20     lelong          103             \b, Hitachi SH3
>20     lelong          104             \b, Hitachi SH4
>20     lelong          0xA11           \b, StrongARM
>20     lelong          4000            \b, MIPS R4000
>20     lelong          10003           \b, Hitachi SH3
>20     lelong          10004           \b, Hitachi SH3E
>20     lelong          10005           \b, Hitachi SH4
>20     lelong          70001           \b, ARM 7TDMI
>52     leshort         1               \b, 1 file
>52     leshort         >1              \b, %u files
>56     leshort         1               \b, 1 registry entry
>56     leshort         >1              \b, %u registry entries

0       string  \x00\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20        LBR archive data
>12     string  !\x00x00                                                {invalid}

# Parity archive reconstruction file, the 'par' file format now used on Usenet.
0       string          PAR\0   PARity archive data
>48     leshort         =0      - Index file
>48     leshort         >0      - file number %d

# Felix von Leitner <felix-file@fefe.de>
0       string  d8:announce     BitTorrent file

# BSA archives, based on http://forum.step-project.com/topic/5033-ramifications-of-bsa-extraction-in-mod-organizer/page-16
0       string          BSA\x00\x67             BSA archive, version: 103,
>8      byte            !0x24                   {invalid}
>8      byte            0x24                    folder records offset: %d
0       string          BSA\x00\x68             BSA archive, version: 104,
>8      byte            !0x24                   {invalid}
>8      byte            0x24                    folder records offset: %d

# Benny Baumann <BenBE@geshi.org>
# XAR archiver, http://code.google.com/p/xar/
0       string          xar!                    XAR archive
>6      beshort         x                       \b, version: %d
>4      ubeshort        x                       \b, header size: %d
>8      ubequad         x                       \b, TOC compressed: %d
>16     ubequad         x                       \b, TOC uncompressed: %d
>24     belong          0                       \b, checksum: none
>24     belong          1                       \b, checksum: SHA1
>24     belong          2                       \b, checksum: MD5

# Borg backup-archive (https://github.com/borgbackup/borg)
0    string    BORG_SEG     BORG Backup Archive





# compressed


#------------------Compression Formats-----------------------------
# Stuffit archives are the de facto standard of compression for Macintosh
# files obtained from most archives. (franklsm@tuns.ca)
# Found in some firmware updates.
0   string      SIT!            StuffIt Archive (data)
>2  string      x               \b: %s
0   string      SITD            StuffIt Deluxe (data)
>2  string      x               \b: %s
0   string      Sef             StuffIt Deluxe Segment (data)
>2  string      x               \b: %s

# Newer StuffIt archives (grant@netbsd.org)
0   string      StuffIt         StuffIt Archive

# AFX compressed files (Wolfram Kleff)
2    string        -afx         AFX compressed file data
>6   string        !-           {invalid}

# bzip2
0    string BZh91AY&SY    {location:0}bzip2 compressed data, block size = 900k
0    string BZh81AY&SY    {location:0}bzip2 compressed data, block size = 800k
0    string BZh71AY&SY    {location:0}bzip2 compressed data, block size = 700k
0    string BZh61AY&SY    {location:0}bzip2 compressed data, block size = 600k
0    string BZh51AY&SY    {location:0}bzip2 compressed data, block size = 500k
0    string BZh41AY&SY    {location:0}bzip2 compressed data, block size = 400k
0    string BZh31AY&SY    {location:0}bzip2 compressed data, block size = 300k
0    string BZh21AY&SY    {location:0}bzip2 compressed data, block size = 200k
0    string BZh11AY&SY    {location:0}bzip2 compressed data, block size = 100k

# lzop from <markus.oberhumer@jk.uni-linz.ac.at>
0       string          \x89\x4c\x5a\x4f\x00\x0d\x0a\x1a\x0a    {location:0}lzop compressed data,
>9      beshort         >0x093F                                 {invalid}
>9      beshort         <0x0940
>>9     byte&0xf0       =0x00                                   - version 0.
>>9     beshort&0x0fff  x                                       \b%03x,
>>9     beshort&0x0fff  <1                                      {invalid}
>>13    byte            1                                       LZO1X-1,
>>13    byte            2                                       LZO1X-1(15),
>>13    byte            3                                       LZO1X-999,
>>14    byte            =0x00                                   os: MS-DOS
>>14    byte            =0x01                                   os: Amiga
>>14    byte            =0x02                                   os: VMS
>>14    byte            =0x03                                   os: Unix
>>14    byte            =0x05                                   os: Atari
>>14    byte            =0x06                                   os: OS/2
>>14    byte            =0x07                                   os: MacOS
>>14    byte            =0x0A                                   os: Tops/20
>>14    byte            =0x0B                                   os: WinNT
>>14    byte            =0x0E                                   os: Win32
>9      beshort         >0x0939
>>9     byte&0xf0       =0x00                                   - version 0.
>>9     byte&0xf0       =0x10                                   - version 1.
>>9     byte&0xf0       =0x20                                   - version 2.
>>9     beshort&0x0fff  x                                       \b%03x,
>>15    byte            1                                       LZO1X-1,
>>15    byte            2                                       LZO1X-1(15),
>>15    byte            3                                       LZO1X-999,
>>17    byte            =0x00                                   os: MS-DOS
>>17    byte            =0x01                                   os: Amiga
>>17    byte            =0x02                                   os: VMS
>>17    byte            =0x03                                   os: Unix
>>17    byte            =0x05                                   os: Atari
>>17    byte            =0x06                                   os: OS/2
>>17    byte            =0x07                                   os: MacOS
>>17    byte            =0x0A                                   os: Tops/20
>>17    byte            =0x0B                                   os: WinNT
>>17    byte            =0x0E                                   os: Win32

# lzip
0       string          LZIP            {location:0}lzip compressed data,
>4      ubyte           0               {invalid}
# Current version is still 1.x
>4      ubyte           >4              {invalid}
>4      byte            x               version: %d

# lrzip
0       string          LRZI            lrzip compressed data

# LZO
0    string        \211LZO\000\015\012\032\012    LZO compressed data

# 7-zip archiver, from Thomas Klausner (wiz@danbala.tuwien.ac.at)
# http://www.7-zip.org or DOC/7zFormat.txt
#
0     string    7z\274\257\047\034      {location:0}7-zip archive data,
>6    byte      <0                      {invalid}
>6    byte      0
>>7   byte      0                       {invalid}
>6    byte      >20                     {invalid}
>6    byte      x                       version %d
>7    byte      x                       \b.%d

# standard unix compress
# Disabled until a python alternative can be found for the compress binwalk plugin.
#0       string        \x1f\x9d\x90          compress'd data, 16 bits

# http://tukaani.org/xz/xz-file-format.txt
0    string        \xFD\x37\x7a\x58\x5a\x00    xz compressed data

# gzip (GNU zip, not to be confused with Info-ZIP or PKWARE zip archiver)
#   Edited by Chris Chittleborough <cchittleborough@yahoo.com.au>, March 2002
#       * Original filename is only at offset 10 if "extra field" absent
#       * Produce shorter output - notably, only report compression methods
#         other than 8 ("deflate", the only method defined in RFC 1952).
#0       string          \037\213\x08    gzip compressed data
0       string          \x1f\x8b\x08    {location:0}gzip compressed data
>3      byte            &0x01           \b, ASCII
>3      byte&0xE0       !0x00           \b, {invalid}invalid reserved flag bits
>8      byte            2               \b, maximum compression
>8      byte            4               \b, fastest compression
>8      byte            1               \b, {invalid}invalid extra flags
>8      byte            3               \b, {invalid}invalid extra flags
>8      byte            >4              \b, {invalid}invalid extra flags
>3      byte            &0x02           \b, has header CRC
>3      byte&0x04       0x04
>>10    leshort         x               \b, has %d bytes of extra data
>>10    leshort         <0              {invalid}(invalid extra data size)
>3      byte&0xC        =0x08           \b, has original file name
>>10    string          x               \b: "%s"{name:%s}
>3      byte            &0x10           \b, has comment
>>3     byte&0xC        0
>>>10   string          x               \b: "%s"
>9      byte            =0x00           \b, from FAT filesystem (MS-DOS, OS/2, NT)
>9      byte            =0x01           \b, from Amiga
>9      byte            =0x02           \b, from VMS
>9      byte            =0x03           \b, from Unix
>9      byte            =0x04           \b, from VM/CMS
>9      byte            =0x05           \b, from Atari
>9      byte            =0x06           \b, from HPFS filesystem (OS/2, NT)
>9      byte            =0x07           \b, from MacOS
>9      byte            =0x08           \b, from Z-System
>9      byte            =0x09           \b, from CP/M
>9      byte            =0x0A           \b, from TOPS/20
>9      byte            =0x0B           \b, from NTFS filesystem (NT)
>9      byte            =0x0C           \b, from QDOS
>9      byte            =0x0D           \b, from Acorn RISCOS
>3      byte            &0x20           \b, encrypted{invalid}
# Dates before 1992 are {invalid}, unless of course you're DD-WRT in which
# case you don't know how to set a date in your gzip files. Brilliant.
>4      uledate         x               \b, last modified: %s
>4      lelong          =0              (null date)
>4      lelong          !0
>>4     lelong          <694224000      (bogus date)
>>4     lelong          =694224000      (bogus date)


# Supplementary magic data for the file(1) command to support
# rzip(1).  The format is described in magic(5).
#
# Copyright (C) 2003 by Andrew Tridgell.  You may do whatever you want with
# this file.
#
0       string          RZIP            rzip compressed data
>4      byte            x               - version %d
>5      byte            x               \b.%d
>6      belong          x               (%d bytes)

# JAR
0       belong          0xcafed00d      JAR compressed with pack200,
>5      byte            x               version %d.
>4      byte            x               \b%d

# New LZMA format signature
# See lzma file for LZMA signatures
0     string        \xFFLZMA\x00    {location:0}LZMA compressed data (new),
>6    byte&0x10     0               single-block stream
>6    byte&0x10     0x10            multi-block stream

0    string    \xff\x06\x00\x00\x73\x4e\x61\x50\x70\x59    Snappy compression, stream identifier

# KGB Archiver http://www.garykessler.net/library/file_sigs.html
0    string    \x4B\x47\x42\x5F\x61\x72\x63\x68\x20\x2D    KGB archive

#0    beshort        0x7801        Zlib header, no compression
0    beshort        0x789c        {location:0}Zlib compressed data, default compression
0    beshort        0x78da        {location:0}Zlib compressed data, best compression
0    beshort        0x785e        {location:0}Zlib compressed data, compressed

# http://justsolve.archiveteam.org/wiki/LZ4
0    belong         0x04224D18    {location:0}LZ4 compressed data
0    belong         0x02214C18    {location:0}LZ4 compressed data, legacy



# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x51
# ------------------------------------------------------------------
0        string    \x51\x00\x00    LZMA compressed data, properties: 0x51,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}

# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x5A
# ------------------------------------------------------------------
0        string    \x5A\x00\x00    LZMA compressed data, properties: 0x5A,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x5B
# ------------------------------------------------------------------
0        string    \x5B\x00\x00    LZMA compressed data, properties: 0x5B,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x5C
# ------------------------------------------------------------------
0        string    \x5C\x00\x00    LZMA compressed data, properties: 0x5C,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x5D
# ------------------------------------------------------------------
0        string    \x5D\x00\x00    LZMA compressed data, properties: 0x5D,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
# Some oddball LZMA implementations use the 0x5D properties byte,
# but don't include the ucompressed size. For this specific LZMA
# property, don't check the uncompressed size here (it is validated
# in a plugin).
#>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x5E
# ------------------------------------------------------------------
0        string    \x5E\x00\x00    LZMA compressed data, properties: 0x5E,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x63
# ------------------------------------------------------------------
0        string    \x63\x00\x00    LZMA compressed data, properties: 0x63,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x64
# ------------------------------------------------------------------
0        string    \x64\x00\x00    LZMA compressed data, properties: 0x64,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x65
# ------------------------------------------------------------------
0        string    \x65\x00\x00    LZMA compressed data, properties: 0x65,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x66
# ------------------------------------------------------------------
0        string    \x66\x00\x00    LZMA compressed data, properties: 0x66,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x6C
# ------------------------------------------------------------------
0        string    \x6C\x00\x00    LZMA compressed data, properties: 0x6C,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x6D
# ------------------------------------------------------------------
0        string    \x6D\x00\x00    LZMA compressed data, properties: 0x6D,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x6E
# ------------------------------------------------------------------
0        string    \x6E\x00\x00    LZMA compressed data, properties: 0x6E,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x75
# ------------------------------------------------------------------
0        string    \x75\x00\x00    LZMA compressed data, properties: 0x75,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x76
# ------------------------------------------------------------------
0        string    \x76\x00\x00    LZMA compressed data, properties: 0x76,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x7E
# ------------------------------------------------------------------
0        string    \x7E\x00\x00    LZMA compressed data, properties: 0x7E,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x87
# ------------------------------------------------------------------
0        string    \x87\x00\x00    LZMA compressed data, properties: 0x87,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x88
# ------------------------------------------------------------------
0        string    \x88\x00\x00    LZMA compressed data, properties: 0x88,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x89
# ------------------------------------------------------------------
0        string    \x89\x00\x00    LZMA compressed data, properties: 0x89,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x8A
# ------------------------------------------------------------------
0        string    \x8A\x00\x00    LZMA compressed data, properties: 0x8A,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x8B
# ------------------------------------------------------------------
0        string    \x8B\x00\x00    LZMA compressed data, properties: 0x8B,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x90
# ------------------------------------------------------------------
0        string    \x90\x00\x00    LZMA compressed data, properties: 0x90,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x91
# ------------------------------------------------------------------
0        string    \x91\x00\x00    LZMA compressed data, properties: 0x91,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x92
# ------------------------------------------------------------------
0        string    \x92\x00\x00    LZMA compressed data, properties: 0x92,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x93
# ------------------------------------------------------------------
0        string    \x93\x00\x00    LZMA compressed data, properties: 0x93,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x99
# ------------------------------------------------------------------
0        string    \x99\x00\x00    LZMA compressed data, properties: 0x99,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x9A
# ------------------------------------------------------------------
0        string    \x9A\x00\x00    LZMA compressed data, properties: 0x9A,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x9B
# ------------------------------------------------------------------
0        string    \x9B\x00\x00    LZMA compressed data, properties: 0x9B,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xA2
# ------------------------------------------------------------------
0        string    \xA2\x00\x00    LZMA compressed data, properties: 0xA2,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xA3
# ------------------------------------------------------------------
0        string    \xA3\x00\x00    LZMA compressed data, properties: 0xA3,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xAB
# ------------------------------------------------------------------
0        string    \xAB\x00\x00    LZMA compressed data, properties: 0xAB,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xB4
# ------------------------------------------------------------------
0        string    \xB4\x00\x00    LZMA compressed data, properties: 0xB4,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xB5
# ------------------------------------------------------------------
0        string    \xB5\x00\x00    LZMA compressed data, properties: 0xB5,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xB6
# ------------------------------------------------------------------
0        string    \xB6\x00\x00    LZMA compressed data, properties: 0xB6,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xB7
# ------------------------------------------------------------------
0        string    \xB7\x00\x00    LZMA compressed data, properties: 0xB7,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xB8
# ------------------------------------------------------------------
0        string    \xB8\x00\x00    LZMA compressed data, properties: 0xB8,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xBD
# ------------------------------------------------------------------
0        string    \xBD\x00\x00    LZMA compressed data, properties: 0xBD,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xBE
# ------------------------------------------------------------------
0        string    \xBE\x00\x00    LZMA compressed data, properties: 0xBE,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xBF
# ------------------------------------------------------------------
0        string    \xBF\x00\x00    LZMA compressed data, properties: 0xBF,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xC0
# ------------------------------------------------------------------
0        string    \xC0\x00\x00    LZMA compressed data, properties: 0xC0,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xC6
# ------------------------------------------------------------------
0        string    \xC6\x00\x00    LZMA compressed data, properties: 0xC6,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xC7
# ------------------------------------------------------------------
0        string    \xC7\x00\x00    LZMA compressed data, properties: 0xC7,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xC8
# ------------------------------------------------------------------
0        string    \xC8\x00\x00    LZMA compressed data, properties: 0xC8,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xCF
# ------------------------------------------------------------------
0        string    \xCF\x00\x00    LZMA compressed data, properties: 0xCF,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xD0
# ------------------------------------------------------------------
0        string    \xD0\x00\x00    LZMA compressed data, properties: 0xD0,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xD8
# ------------------------------------------------------------------
0        string    \xD8\x00\x00    LZMA compressed data, properties: 0xD8,
>1        lelong    x        dictionary size: %d bytes,
>5        lequad    x        uncompressed size: %lld bytes
# Assume that a valid size will be greater than 32 bytes.
# This could technically be valid, but is unlikely.
# A value of -1 IS valid!
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad   >1000000000000 {invalid}



# ------------------------------------------------------------------
# Hex, TI-TXT and Motorola S-Record signatures 
# ------------------------------------------------------------------

# Intel HEX
0   regex       (\:([0-9a-fA-F]{2}){5,}(\n|\r\n))+    Intel HEX data{many}, record type:
>7  string      00                          data
>7  string      01                          end of file
>7  string      02                          extended segment address
>7  string      03                          start segment address
>7  string      04                          extended linear address
>7  string      05                          start linear address
>7  ubeshort    >0x3035                     unknown {invalid}

# TI TXT : (https://www.ti.com/lit/ug/slau101q/slau101q.pdf?ts=1703004547069&ref_url=https%253A%252F%252Fwww.google.com%252F section A.2)
# @ADDRES
0   regex       (@[0-9A-Fa-f]+\s*(\n|\r\n))+                     TI-TXT File Format{many} {location:0}
# Hex byte plus single space 
>6  regex       (?![0-9A-Fa-f]+\x20)                             
>>7 regex       (?![0-9A-Fa-f]+\x20)                             {invalid}


# Motorola S-Records, from Gerd Truschinski <gt@freebsd.first.gmd.de>
# Improved by Martin Sundhaug <martinsundhaug@gmail.com>
0   regex       (S[0-35-9]([0-9a-fA-F]{4})([0-9a-fA-F]{2})+(\n|\r\n))+       Motorola S-Record{many}; binary data in text format, record type:
>1  string      0                                               header
>1  string      1                                               data (16-bit)
>1  string      2                                               data (24-bit)
>1  string      3                                               data (32-bit)
>1  string      4                                               reserved
>1  string      5                                               count (16-bit)
>1  string      6                                               count (24-bit)
>1  string      7                                               start address (32-bit)
>1  string      8                                               start address (24-bit)
>1  string      9                                               start address (16-bit)
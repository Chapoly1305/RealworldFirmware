import binwalk.core.plugin


def ldiff_bit(a : int, b : int):
    '''
    the number of bits before the first different bit
    '''
    c = a ^ b
    num = 0
    for idx in range(31,0,-1):
        if c & (0x1 << idx) != 0x0:
            break
        num += 1
    return num


# Each plugin must be subclassed from binwalk.core.plugin.Plugin
class VecTable(binwalk.core.plugin.Plugin):
    '''
    A binwalk plugin module to identify the vector table in the file
    TODO: specify the firmware is little endian
    TODO: get the longest common prefix of irq handler pointer
    '''

    MODULES = ['Signature']
    # the min common prefix defined by user currently is 3 hex
    # TODO: need to generated by more test suites
    MINPREFIX = 12
    # the size of entries to check
    VECENTRYNUM = 16
    # [offset, entry_reserved, common_prefix]
    VecTable = []
    # the bytes of file
    FileBytes = b''

    def min_common_prefix(self, i):
        '''
        the min common prefix of the vector table
        '''
        bytes = self.FileBytes
        prev = int.from_bytes(bytes[i:i+4], 'little')
        prefix = 0xffff
        i += 4
        # consider 16 entries without external interrupts
        while i <= self.VECENTRYNUM*4:
            cur = int.from_bytes(bytes[i:i+4], 'little')
            # not reserved entry
            if cur != 0:
                # the min prefix
                prefix = min(ldiff_bit(cur, prev),prefix)
                prev = cur
            i += 4
        return prefix

    def init(self):
        return
    def pre_scan(self):
        return
    def new_file(self, fp):
        # disable this plugin
        return
        with open(fp.path, 'rb') as file:
            self.FileBytes = file.read()
            bytes = self.FileBytes
        for idx in range(0, len(bytes)-64):
            # the magic number of stack top pointer
            # TODO: use 0x00 with 0x20 or just 0x20
            if bytes[idx] == 0x00 and bytes[idx+1] == 0x20:
                i = idx + 2
                prev = bytes[i:i+4]
                entrys = 0x0
                if prev != b'\x00\x00\x00\x00':
                    entrys = 0x1
                i += 4
                # consider 16 entries without external interrupts
                while i <= (idx + self.VECENTRYNUM*4 - 2):
                    entrys <<= 1
                    cur = bytes[i:i+4]
                    # not reserved entry
                    if cur != b'\x00\x00\x00\x00':
                        # min prefix match
                        start_byte = 4 - (self.MINPREFIX // 8)
                        end_bit    = 8 - (self.MINPREFIX %  8)
                        byte_match = (cur[start_byte:] == prev[start_byte:])
                        bit_match  = ((cur[start_byte-1] >> end_bit) == (prev[start_byte-1] >> end_bit))
                        # the last byte can not be in SRAM
                        if cur[3] >= 0x20 or not byte_match or not bit_match:
                            break
                        prev = cur
                        entrys |= 1
                    i += 4
                if i == (idx+ self.VECENTRYNUM*4 + 2):
                   self.VecTable.append([idx-2, entrys, self.min_common_prefix(idx+2)])


    def scan(self, result):
        return

    def post_scan(self):
        # disable this plugin
        return
        if len(self.VecTable) == 0:
            return
        for offset,entry,prefix in self.VecTable:
            print("%d\t    0x%x\t     Vector Table for ARM little endian, prefix 0x%x reserved entrys %s" %(offset,offset,prefix,bin(entry)))
